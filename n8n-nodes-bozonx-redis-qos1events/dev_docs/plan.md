# План: нода-действие для отправки событий в Redis Streams

## Цель
- Реализовать ноду n8n (действие) для публикации событий в Redis Stream с управлением `messageId`, полями сообщения и базовыми опциями очереди.
- Гарантировать совместимость с моделью доставки «хотя бы один получатель» через Consumer Groups (на стороне подписчиков).

## Ключевые моменты
- Производитель (наша нода) публикует сообщения командой `XADD` в указанный Stream.
- «Хотя бы один подписчик» достигается за счёт потребителей, читающих через `XREADGROUP` в составе одного Consumer Group — каждое сообщение доставляется одному из потребителей группы (at-least-once с последующим `XACK`). Для «сразу нескольким» — используйте несколько групп (каждая группа получит сообщение независимо).
- Идемпотентность: задание фиксированного `messageId` (не `*`) позволит избежать дублей при повторных публикациях, если бизнес-логика требует.

## Технический стек
- Node.js 22, TypeScript.
- Библиотека клиента Redis: официальная `redis` (node-redis) v4+.
- Пакет — community node для n8n с использованием `@n8n/node-cli`.

## Структура проекта (новые файлы)
- `credentials/Redis.credentials.ts` — креды для подключения к Redis.
- `nodes/RedisStreamProducer/RedisStreamProducer.node.ts` — нода-действие.
- `nodes/RedisStreamProducer/redisClient.ts` — хелпер для подключения/переиспользования клиента.
- `dev_docs/` — текущий план и заметки.
- `compose.yaml` — локальный стенд Redis + (опционально) RedisInsight.

## Параметры ноды (черновик)
- **Credentials**: `Redis` (host, port, username, password, TLS — опционально, DB index).
- **Stream Key**: string (обязательно). Ключ Redis Stream, например `events:stt`.
- **Message ID**: string (по умолчанию `*`). При необходимости задать фиксированный ID.
- **Payload Mode**: options — `json` | `flatten`.
  - `json`: отправлять одной парой `field:"data"`, значение — `JSON.stringify($json)`.
  - `flatten`: разворачивать `item.json` в пары field=value (все значения строковые, вложенные объекты — `JSON.stringify`).
- **Additional Fields**: коллекция пользовательских полей (добавляются к сообщению помимо входных данных).
- **MAXLEN Approx**: number (опционально). Использовать `MAXLEN ~ <N>` для ограничения длины потока.
- **EXPIRATION (stream key TTL)**: number (секунды, опционально). Выполнить `EXPIRE <key> <ttl>` после `XADD`.
- **Return**: вернуть сгенерированный `id` сообщения и echo-данные.

## Поведение `execute`
1. Инициализировать singleton Redis клиента из кредов.
2. На каждый входной item:
   - Сформировать поля сообщения по выбранному режиму + дополнительные поля.
   - Выполнить `XADD <stream> [MAXLEN ~ N] <messageId|*> field1 value1 field2 value2 ...`.
   - Если задан `TTL`, выполнить `EXPIRE <stream> <ttl>` (best-effort).
   - Вернуть `{ stream, id, fields }` с привязкой к item.
3. Обработка ошибок — через `continueOnFail` с сообщением об ошибке в результате item.

## Креды `Redis`
- Поля: `host`, `port`, `username` (optional), `password` (optional), `useTLS` (boolean), `db` (number, default 0).
- Формирование URL/опций для клиента `redis.createClient`.

## Ограничения и заметки
- Производитель не может «гарантировать» наличие подписчиков. Для сценария «хотя бы один» полагайтесь на корректную конфигурацию Consumer Group(ов) на стороне подписчиков и мониторинг Pending списка.
- Для «сразу нескольким» — используйте несколько Consumer Groups; нода-производитель публикует один раз.
- Точная ровно-однажды доставка недостижима без внешней идемпотентности; используйте фиксированный `messageId` и идемпотентные потребители.

## Тестирование (локально)
1. Запустить Redis: `docker compose up -d` в корне пакета.
2. Подготовить группу:
   - `redis-cli XGROUP CREATE mystream mygroup $ MKSTREAM`
3. Протестировать ноду в n8n (dev режим пакета):
   - Поток: любой источник данных → RedisStreamProducer.
   - Проверить запись: `redis-cli XREADGROUP GROUP mygroup c1 COUNT 10 STREAMS mystream >` и `XACK mystream mygroup <id>`.

## Дальнейшие шаги (после ноды-действия)
- Добавить ноду-триггер `RedisStreamConsumer` (отдельный node type), читающую через `XREADGROUP` с настройками Block, Ack, Auto-claim и т.д.
- Добавить наблюдение за pending/idle, retry-политику.

## Ответ на вопрос: одна нода для действия и триггера?
- В n8n триггеры и действия — разные типы нод (`trigger/webhook` vs `execute`). Объединять в одном классе не поддерживается.
- Рекомендация: реализовывать два отдельных node types в одном пакете: `...Trigger` и `...` (action). Сейчас делаем только действие.
