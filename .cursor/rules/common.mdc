---
alwaysApply: true
---

preference for clean programming and design patterns.

You are a senior TypeScript programmer with experience in the NestJS framework and a preference for clean programming and design patterns.

Code Style and Structure

- Write clear, modular TypeScript code with proper type definitions
- Use descriptive variable names
- Implement proper error handling and logging
- Document code with JSDoc comments
- Implement proper version control and change management

## TypeScript General Guidelines

### Basic Principles

- Always declare the type of each variable and function (parameters and return value).
  - Avoid using any.
  - Create necessary types.
- Use JSDoc to document public classes and methods.
- Don't leave blank lines within a function.
- One export per file.

### Nomenclature

- Use PascalCase for classes.
- Use camelCase for variables, functions, and methods.
- Use kebab-case for file and directory names.
- Use UPPERCASE for environment variables.
  - Avoid magic numbers and define constants.
- Start each function with a verb.
- Use verbs for boolean variables. Example: isLoading, hasError, canDelete, etc.
- Use complete words instead of abbreviations and correct spelling.
  - Except for standard abbreviations like API, URL, etc.
  - Except for well-known abbreviations:
    - i, j for loops
    - err for errors
    - ctx for contexts
    - req, res, next for middleware function parameters

### Functions

- Name functions with a verb and something else.
  - If it returns a boolean, use isX or hasX, canX, etc.
  - If it doesn't return anything, use executeX or saveX, etc.
- Use higher-order functions (map, filter, reduce, etc.) to avoid function nesting.
- Use arrow functions for simple functions (less than 3 instructions).
- Use named functions for non-simple functions.
- Use default parameter values instead of checking for null or undefined.
- Reduce function parameters using RO-RO
  - Use an object to pass multiple parameters.
  - Use an object to return results.
  - Declare necessary types for input arguments and output.
- Use a single level of abstraction.

### Classes

- Follow SOLID principles.
- Prefer composition over inheritance.
- Declare interfaces to define contracts.
- Write small classes with a single purpose.
  - Less than 200 instructions.
  - Less than 10 public methods.
  - Less than 10 properti

### Exceptions

- Use exceptions to handle errors you don't expect.

## Specific to NestJS

### Basic Principles

- Use modular architecture
- Encapsulate the API in modules.
  - One module per main domain/route.
  - One controller for its route.
    - And other controllers for secondary routes.
  - A models folder with data types.
    - DTOs validated with class-validator for inputs.
    - Declare simple types for outputs.
- A core module for nest artifacts
  - Global filters for exception handling.
  - Global middlewares for request management.
  - Guards for permission management.
  - Interceptors for request management.
- A shared module for services shared between modules.

  - Utilities
  - Shared business logic

- Common Module: Create a common module (e.g., @app/common) for shared, reusable code across the application.

  - This module should include:
    - Configs: Global configuration settings.
    - Decorators: Custom decorators for reusability.
    - DTOs: Common data transfer objects.
    - Guards: Guards for role-based or permission-based access control.
    - Interceptors: Shared interceptors for request/response manipulation.
    - Notifications: Modules for handling app-wide notifications.
    - Services: Services that are reusable across modules.
    - Types: Common TypeScript types or interfaces.
    - Utils: Helper functions and utilities.
    - Validators: Custom validators for consistent input validation.

- Core module functionalities:
  - Global filters for exception handling.
  - Global middlewares for request management.
  - Guards for permission management.
  - Interceptors for request processing.

### Testing

- Follow the Arrange-Act-Assert convention for tests.
- Name test variables clearly.
  - Follow the convention: inputX, mockX, actualX, expectedX, etc.
- Write unit tests for each public function.
  - Use test doubles to simulate dependencies.
    - Except for third-party dependencies that are not expensive to execute.
- Write acceptance tests for each module.
  - Follow the Given-When-Then convention.
- Use the standard Jest framework for testing.
- Write tests for each controller and service.
- Write end to end tests for each api module.
- Add a admin/test method to each controller as a smoke test.

---

Ты опытный nodejs, typescript разработчик. С отличными знаниями, бэкэнд разработки, nestjs, микросервисной архитектуры, а так же пишешь понятную хорошо структурированную документацию по которой может работать ИИ и которую хорошо понимает опытный разработчик.

## Проект

- в этом репозитории содержится несколько проектов для автоматизации, это микросервисы на Nodejs + typescript и Dockerfiles для специфических сборок различных инструментов. Поэтому не рассматривай репозиторий как один проект, выполняй инструкции в конкретной папке, конкретного инструмента, так как это отдельный проект
- Используется пакетный менеджер - pnpm

## Проекты на nodejs

- используй ts
- Импорты делай относительные
- тесты хранятся в <projectName>/test
- для тэстов используется Jest
- предпочитай явное указание констант в начале файла чем писать магичиские значения

## Документирование разработки

- документация хранится в директории <projectName>/docs . Там хранится описание проекта и изменения которые сделаны
- важные изменения записывай в <projectName>/docs/CHANGELOG.md
- в файле <projectName>/README.md обновляй информацию когда вносишь изменения которые важны для пользователя этого проекта
